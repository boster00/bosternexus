# Boster Nexus Cursor Rules (Security + Architecture Constitution)

## 0) Branding Guidelines
**CRITICAL: Customer-facing branding rules**
- Brand name: **Boster** or **Boster Bio** (NEVER "BosterNexus" in customer UI)
- Domain: bosterbio.com
- "Boster Nexus" is the internal system name for the platform/business intelligence system
- All customer-facing UI, emails, documents MUST use "Boster" or "Boster Bio"
- Internal code, logs, system names may use "BosterNexus" or "Nexus"
- Repository name "bosternexus" is acceptable for internal reference only

## A) Fundamental boundary model
- Next.js (apps/web) is a presentation layer only. It renders data and calls APIs.
- NestJS (apps/api) is the only place where business logic, database access, and integrations occur.
- DO NOT blend frontend/backend responsibilities.

## B) Next.js restrictions
- Next.js pages/layouts/routes MUST NOT implement business logic.
- Next.js MUST NOT access the database directly.
- Next.js MUST NOT call external services directly (Zoho/FedEx/email/search providers).
- Next.js may only call backend via `apps/web/src/client-api/*` (single client surface).
- Avoid Next.js Server Actions for business logic. Use explicit REST endpoints in NestJS.

## C) NestJS layering
- Controllers contain no business logic: validate DTOs, call facades, return responses.
- Facades are the only entry points used by controllers.
- Orchestrators coordinate use-cases and call pipelines/services.
- Domain logic is pure and does not depend on HTTP, Context, DB, or integrations.
- Integrations live in `src/integrations/**` only.

## D) Strict input validation (security boundary)
- Every endpoint MUST validate request payloads with strict schemas:
  - deny unknown keys
  - validate nested structures
  - enforce types, lengths, enums
- If validation fails: return 400 with safe error, log structured detail internally.
- NEVER trust client-provided structured payloads beyond the validated schema.

## E) Context policy
- AsyncLocalStorage context may be used only in controllers/facades/orchestrators/integrations/logging.
- Domain logic MUST NOT read Context.current().
- Do not store or log secrets/tokens/PII in context.

## F) Idempotency + transaction safety
- Any operation that creates/mutates external state MUST require idempotency key.
- Checkout/order flows MUST be implemented as state transitions via TransactionService.
- Add a watchdog that alerts on stuck transactions.

## G) External calls and secrets
- External calls must go through an `ExternalApiClient` base with timeouts/retries/logging.
- Secrets must be read from environment variables only; no hardcoding.
- Log redaction required for tokens, auth headers, email addresses where possible.

## H) Styling
- Tailwind is the default styling system in apps/web.
- globals.css is restricted to Tailwind directives + CSS variable tokens + minimal reset.
- No page-specific styling in global CSS.

## I) Product image organization
- Product images use Magento-style SKU-based subfolder structure.
- Images are organized by first two letters of SKU (lowercase).
- Example: SKU "PA1012" → `/media/images/products/p/a/PA1012-image.jpg`
- Example: SKU "BD2345" → `/media/images/products/b/d/BD2345-thumb.jpg`
- This prevents directory bloat and maintains performance at scale.

## J) Scope control for skeleton regen
- Build only: health endpoint, search example, transaction watchdog skeleton, docker/nginx wiring.
- Do NOT build full PIM/CMS/admin/payment capture yet.
